<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeoMed - Twilio Video</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Inter", "Segoe UI", Arial, sans-serif;
      }
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #0f172a;
        color: #e2e8f0;
      }
      .shell {
        display: grid;
        grid-template-rows: auto 1fr auto;
        width: 100%;
        height: 100%;
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.95);
        font-size: 13px;
      }
      .room {
        opacity: 0.9;
      }
      .status {
        font-weight: 600;
      }
      .status.error {
        color: #fca5a5;
      }
      .status.ok {
        color: #86efac;
      }
      .main {
        position: relative;
        overflow: hidden;
      }
      .remote {
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 8px;
        padding: 8px;
        box-sizing: border-box;
      }
      .tile {
        position: relative;
        border-radius: 10px;
        overflow: hidden;
        background: #1e293b;
        min-height: 180px;
      }
      .tile video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        background: #020617;
      }
      .label {
        position: absolute;
        left: 8px;
        bottom: 8px;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(2, 6, 23, 0.75);
      }
      .local {
        position: absolute;
        right: 10px;
        bottom: 10px;
        width: 24%;
        min-width: 130px;
        max-width: 220px;
        aspect-ratio: 16 / 9;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: #020617;
        z-index: 2;
      }
      .local video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }
      .footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-top: 1px solid rgba(148, 163, 184, 0.25);
        font-size: 12px;
        background: rgba(15, 23, 42, 0.95);
      }
      .btn {
        border: 0;
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        background: #0ea5e9;
        color: #082f49;
      }
      .btn:disabled {
        cursor: default;
        opacity: 0.6;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="header">
        <div class="room" id="roomLabel">Sala: -</div>
        <div class="status" id="statusLabel">Conectando...</div>
      </div>
      <div class="main">
        <div class="remote" id="remoteContainer"></div>
        <div class="local" id="localContainer"></div>
      </div>
      <div class="footer">
        <span id="identityLabel">Participante: -</span>
        <button class="btn" id="reconnectBtn" type="button">Reconectar</button>
      </div>
    </div>

    <script src="https://sdk.twilio.com/js/video/releases/2.29.0/twilio-video.min.js"></script>
    <script>
      (function () {
        const params = new URLSearchParams(window.location.search);
        const roomName = String(params.get('roomName') || params.get('room') || '').trim();
        const identityParam = String(params.get('identity') || '').trim();
        const authToken = localStorage.getItem('neomed_auth_token') || '';
        const userRaw = localStorage.getItem('neomed_auth_user') || '{}';

        let room = null;
        let reconnecting = false;

        const roomLabel = document.getElementById('roomLabel');
        const statusLabel = document.getElementById('statusLabel');
        const identityLabel = document.getElementById('identityLabel');
        const remoteContainer = document.getElementById('remoteContainer');
        const localContainer = document.getElementById('localContainer');
        const reconnectBtn = document.getElementById('reconnectBtn');

        const fallbackIdentity = (() => {
          try {
            const parsed = JSON.parse(userRaw);
            return String(parsed.displayName || parsed.email || parsed.uid || 'usuario');
          } catch {
            return 'usuario';
          }
        })();

        const identity = identityParam || fallbackIdentity;

        const setStatus = (message, error) => {
          statusLabel.textContent = message;
          statusLabel.className = error ? 'status error' : 'status ok';
        };

        const createTile = (labelText) => {
          const tile = document.createElement('div');
          tile.className = 'tile';
          const label = document.createElement('span');
          label.className = 'label';
          label.textContent = labelText;
          tile.appendChild(label);
          return tile;
        };

        const attachTrack = (track, container) => {
          const node = track.attach();
          if (track.kind === 'video') {
            container.appendChild(node);
          }
          if (track.kind === 'audio') {
            node.style.display = 'none';
            container.appendChild(node);
          }
        };

        const clearContainer = (container) => {
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
        };

        const cleanupRoom = () => {
          if (!room) {
            return;
          }
          room.disconnect();
          room = null;
        };

        const renderParticipant = (participant) => {
          const tile = createTile(participant.identity || 'Participante');
          remoteContainer.appendChild(tile);

          participant.tracks.forEach((publication) => {
            if (publication.track) {
              attachTrack(publication.track, tile);
            }
          });

          participant.on('trackSubscribed', (track) => attachTrack(track, tile));
          participant.on('trackUnsubscribed', (track) => {
            track.detach().forEach((node) => node.remove());
          });

          participant.on('disconnected', () => {
            tile.remove();
          });
        };

        const fetchTwilioToken = async () => {
          if (!authToken) {
            throw new Error('Sessao expirada. Entre novamente no sistema.');
          }
          if (!roomName) {
            throw new Error('Sala de video nao informada.');
          }

          const query = new URLSearchParams({
            roomName,
            identity,
          });

          const response = await fetch(`/api/video/twilio/token?${query.toString()}`, {
            method: 'GET',
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          });

          const payload = await response.json().catch(() => ({}));
          if (!response.ok || !payload?.token) {
            throw new Error(payload?.message || 'Nao foi possivel obter token Twilio.');
          }

          return payload.token;
        };

        const connectRoom = async () => {
          if (!window.Twilio || !window.Twilio.Video) {
            throw new Error('SDK do Twilio nao carregado.');
          }

          clearContainer(remoteContainer);
          clearContainer(localContainer);
          setStatus('Conectando...', false);

          const token = await fetchTwilioToken();
          const activeRoom = await window.Twilio.Video.connect(token, {
            name: roomName,
            audio: true,
            video: { width: 640 },
            dominantSpeaker: true,
          });

          room = activeRoom;
          setStatus('Conectado', false);

          activeRoom.localParticipant.tracks.forEach((publication) => {
            if (publication.track) {
              attachTrack(publication.track, localContainer);
            }
          });

          activeRoom.participants.forEach(renderParticipant);
          activeRoom.on('participantConnected', renderParticipant);
          activeRoom.on('participantDisconnected', () => {});
          activeRoom.on('disconnected', () => {
            setStatus('Desconectado', true);
          });
        };

        const init = async () => {
          roomLabel.textContent = `Sala: ${roomName || '-'}`;
          identityLabel.textContent = `Participante: ${identity || '-'}`;
          reconnectBtn.disabled = true;

          try {
            await connectRoom();
          } catch (error) {
            setStatus(error?.message || 'Falha ao iniciar videochamada.', true);
          } finally {
            reconnectBtn.disabled = false;
          }
        };

        reconnectBtn.addEventListener('click', async () => {
          if (reconnecting) {
            return;
          }
          reconnecting = true;
          reconnectBtn.disabled = true;
          cleanupRoom();
          try {
            await connectRoom();
          } catch (error) {
            setStatus(error?.message || 'Falha ao reconectar.', true);
          } finally {
            reconnecting = false;
            reconnectBtn.disabled = false;
          }
        });

        window.addEventListener('beforeunload', cleanupRoom);
        init();
      })();
    </script>
  </body>
</html>
